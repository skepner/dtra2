sampleIdCeirs :: Record -> T.Text
sampleIdCeirs record =
  let raw = sampleId record
      prependCIP116 = T.take 4 raw == "217-"
  in if prependCIP116
     then T.concat ["CIP116", raw]
     else raw

----------------------------------------------------------------------

  initField {fColumn=48, fTitle="*uuid*", fRecord=setUuid, fExport=uuid, fValidator=validatorUuid, fIgnoreInMerge=True}
  ]

----------------------------------------------------------------------

normalizeFieldTitleText :: T.Text -> T.Text
normalizeFieldTitleText = T.replace "_" " " . T.toLower

validateFieldTitle :: [Cell] -> Field -> Maybe T.Text
validateFieldTitle cells field =
  let colNo = fColumn field
      expected = fTitle field
      cell = case drop colNo cells of
        [] -> CellEmpty
        cc -> head cc
  in
   case (expected, cell) of
    ("*uuid*", _) -> case validatorUuid Dirs.emptyDirectories cell of
                      Right _ -> Nothing
                      Left [t] -> Just $ fieldErrorPrefixS 1 colNo $ T.unpack t
                      _ -> Just $ fieldErrorPrefixS 1 colNo "original database id within DTRA system expected"
    (_, CellString text) | normalizeFieldTitleText text == expected -> Nothing
    _ -> Just $ fieldErrorPrefixS 1 colNo $ "invalid column label: \"" ++ cellAsString cell ++ "\" expected: \"" ++ T.unpack expected ++ "\""

----------------------------------------------------------------------

-- | Source file may contain columns in arbitrary order.
-- Figure out fColumn for each field by its title.
--
-- Returns either errors (e.g. fields not found) or list of Field with
-- fColumn set correctly. If field not found, fColumn is set to
-- -1. If field not found and fCanBeEmpty=False for it, error is
-- raised. Redundant fields found in [Cell] ignored.
findFields :: [Cell] -> [Field] -> Either [T.Text] [Field]
findFields cells {- sourceFields -} =
  foldr (sequenceField . findField) (Right []) {- sourceFields -}
  where
    findField field =
      case L.find (matchCell (fTitle field)) (zip [0..] normalizedCells) of
       Just (index, _)                      -> Right $ field { fColumn = index }
       Nothing | (fTitle field) == "*uuid*" -> Right $ field
       Nothing                              -> if fCanBeEmpty field
                                               then Right $ field { fColumn = -1 }
                                               else Left $ T.concat ["Mandatory column \"", fTitle field, "\" not found"]
    normalizedCells = map normalizeCell cells
    normalizeCell (CellString t) = normalizeFieldTitleText t
    normalizeCell _ = "*not string*"
    matchCell lookFor (_, t) = lookFor == t
    sequenceField (Right field) (Right accum) = Right (field : accum)
    sequenceField (Left err) (Right _) = Left [err]
    sequenceField (Right _) (Left accum) = Left accum
    sequenceField (Left err) (Left accum) = Left (err : accum)

----------------------------------------------------------------------

----------------------------------------------------------------------
{- Field Validators -}
----------------------------------------------------------------------

cellAsInt :: Cell -> Either [T.Text] Int
cellAsInt cell =
  case (readMaybe . cellAsString) cell of
      Just i -> Right i
      Nothing -> Left ["Unrecognized day"]

-- ----------------------------------------------------------------------

validatorUuid :: Validator
-- validatorUuid = validatorRegex "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$" "expected: orinating database id within DTRA system"
validatorUuid = validatorRegex "^.+$" "expected: orinating database id within DTRA system"
