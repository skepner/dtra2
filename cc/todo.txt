sampleIdCeirs :: Record -> T.Text
sampleIdCeirs record =
  let raw = sampleId record
      prependCIP116 = T.take 4 raw == "217-"
  in if prependCIP116
     then T.concat ["CIP116", raw]
     else raw

----------------------------------------------------------------------

  initField {fColumn=48, fTitle="*uuid*", fRecord=setUuid, fExport=uuid, fValidator=validatorUuid, fIgnoreInMerge=True}
  ]

----------------------------------------------------------------------

normalizeFieldTitleText :: T.Text -> T.Text
normalizeFieldTitleText = T.replace "_" " " . T.toLower

validateFieldTitle :: [Cell] -> Field -> Maybe T.Text
validateFieldTitle cells field =
  let colNo = fColumn field
      expected = fTitle field
      cell = case drop colNo cells of
        [] -> CellEmpty
        cc -> head cc
  in
   case (expected, cell) of
    ("*uuid*", _) -> case validatorUuid Dirs.emptyDirectories cell of
                      Right _ -> Nothing
                      Left [t] -> Just $ fieldErrorPrefixS 1 colNo $ T.unpack t
                      _ -> Just $ fieldErrorPrefixS 1 colNo "original database id within DTRA system expected"
    (_, CellString text) | normalizeFieldTitleText text == expected -> Nothing
    _ -> Just $ fieldErrorPrefixS 1 colNo $ "invalid column label: \"" ++ cellAsString cell ++ "\" expected: \"" ++ T.unpack expected ++ "\""

----------------------------------------------------------------------

-- | Source file may contain columns in arbitrary order.
-- Figure out fColumn for each field by its title.
--
-- Returns either errors (e.g. fields not found) or list of Field with
-- fColumn set correctly. If field not found, fColumn is set to
-- -1. If field not found and fCanBeEmpty=False for it, error is
-- raised. Redundant fields found in [Cell] ignored.
findFields :: [Cell] -> [Field] -> Either [T.Text] [Field]
findFields cells {- sourceFields -} =
  foldr (sequenceField . findField) (Right []) {- sourceFields -}
  where
    findField field =
      case L.find (matchCell (fTitle field)) (zip [0..] normalizedCells) of
       Just (index, _)                      -> Right $ field { fColumn = index }
       Nothing | (fTitle field) == "*uuid*" -> Right $ field
       Nothing                              -> if fCanBeEmpty field
                                               then Right $ field { fColumn = -1 }
                                               else Left $ T.concat ["Mandatory column \"", fTitle field, "\" not found"]
    normalizedCells = map normalizeCell cells
    normalizeCell (CellString t) = normalizeFieldTitleText t
    normalizeCell _ = "*not string*"
    matchCell lookFor (_, t) = lookFor == t
    sequenceField (Right field) (Right accum) = Right (field : accum)
    sequenceField (Left err) (Right _) = Left [err]
    sequenceField (Right _) (Left accum) = Left accum
    sequenceField (Left err) (Left accum) = Left (err : accum)

----------------------------------------------------------------------

normalizeField :: Dirs.Directories -> Int -> [Cell] -> Field -> ValidatorResult
normalizeField directories rowNo cells field =
  let colNo = fColumn field
      validate = fValidator field directories
      cell = case drop colNo cells of -- Note empty cells at the tail of cells truncated
        [] -> CellEmpty
        cc -> head cc
  in
   -- trace ("normalizeField " ++ ssheetRowColToString rowNo colNo ++ " " ++ show cell) $
   if colNo >= 0 && cell /= CellEmpty -- negative colNo means field (column) is absent in the source file
   then
     -- trace ("normalizeField " ++ ssheetRowColToString rowNo colNo ++ " " ++ show cell) $
     case validate cell of
      Left [msg] -> Left [fieldErrorPrefixTT rowNo colNo ["\"", cellAsText cell, "\": ", msg]]
      result -> result
   else if fCanBeEmpty field
        then return ""
        else Left [fieldErrorPrefixT rowNo colNo "cannot be empty"]

----------------------------------------------------------------------
{- Field Validators -}
----------------------------------------------------------------------

cellAsInt :: Cell -> Either [T.Text] Int
cellAsInt cell =
  case (readMaybe . cellAsString) cell of
      Just i -> Right i
      Nothing -> Left ["Unrecognized day"]

-- ----------------------------------------------------------------------

validatorUuid :: Validator
-- validatorUuid = validatorRegex "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$" "expected: orinating database id within DTRA system"
validatorUuid = validatorRegex "^.+$" "expected: orinating database id within DTRA system"

----------------------------------------------------------------------

validatorDirectories :: T.Text -> (Dirs.Directories -> T.Text -> Maybe a) -> Validator
validatorDirectories err find directories cell =
  let text = cellAsText cell
  in
   maybe (Left [err]) (\_ -> Right text) (find directories text)

----------------------------------------------------------------------

    updateLocations :: R.MapRecords -> R.EitherErrorsRecords
    updateLocations =
      checkErrors checkRecord
      where
        checkRecord record =
          let sampleId = R.sampleId record
              location = R.location record
              locationRecMaybe = Dirs.locationFind' directories location
              locationRec = fromJust locationRecMaybe
              err fieldName got expected = Left [T.concat [sampleId, ": invalid ", fieldName, " for ", location, ": ", got, " (expected: ", expected, ")",
                                                           ", please leave Province, Country, Latitude, Longitude fields empty to allow system to fill them with the correct content"]]
              checkField fieldName gotF expectedF = unless
                                                    (T.null (gotF record) || U.normalizeText (expectedF locationRec) == U.normalizeText (gotF record))
                                                    (err fieldName (gotF record) (expectedF locationRec))
              checkFieldFloat fieldName gotF expectedF = unless
                                                    (T.null (gotF record) || readFloat (expectedF locationRec) == readFloat (gotF record))
                                                    (err fieldName (gotF record) (expectedF locationRec))
              readFloat :: T.Text -> Float
              readFloat source =
                case (readMaybe . T.unpack . U.normalizeText) source of
                 Just f -> f
                 Nothing -> trace ("updateLocations: No float in " ++ T.unpack source) (-1.0)
          in do
            when (isNothing locationRecMaybe) (Left [T.concat [sampleId, ": location not found: ", location]])
            checkField "province" R.province Dirs.province
            checkField "country" R.country Dirs.country
            checkFieldFloat "latitude" R.latitude Dirs.latitude
            checkFieldFloat "longitude" R.longitude Dirs.longitude
            Right record { R.province=Dirs.province locationRec, R.country=Dirs.country locationRec, R.latitude=Dirs.latitude locationRec, R.longitude=Dirs.longitude locationRec }

    -- Nic 2015-02-10: If 'domesticus' in the species field please autofill behavior as D, All other species entries please autofill behavior as W
    updateBehavior :: R.MapRecords -> R.EitherErrorsRecords
    updateBehavior =
      checkErrors checkRecord
      where
        checkRecord :: R.Record -> R.EitherErrorsRecord
        checkRecord record =
          let species = U.normalizeText $ R.hostSpecies record
              domesticus = "domesticus" `T.isInfixOf` species
              behavior_orig = R.behavior record
              behavior = if not (T.null behavior_orig) then behavior_orig else if domesticus then "D" else "W"
          in
           Right record { R.behavior = behavior }

    -- In version 2 format date fields are constructed from parts (day, month, year) without checking
    checkDates :: R.MapRecords -> R.EitherErrorsRecords
    checkDates =
      checkErrors checkRecord
      where
        checkRecord :: R.Record -> R.EitherErrorsRecord
        checkRecord r =
          case errors of
           [] -> Right r
           _  -> Left errors
          where
            errors =
              concat $ lefts [ validateField "collection date" R.collectionDate
                             , validateField "date of testing" R.dateOfTesting
                             , validateField "serology testing date" R.serologyTestingDate
                             , compareDateFields "collection date > date of testing" R.collectionDate R.dateOfTesting
                             , compareDateFields "collection date > serology testing date" R.collectionDate R.serologyTestingDate
                             ]
            validateField name field =
              case validateDate (field r) of
               Left err -> Left err
               Right _ -> Right r
              where
                validateDate date =
                  case (T.null date, parseDateDayFirst date) of
                   (False, Left err) -> Left [T.concat [R.sampleId r, ": ", name, ": ", err, ": ", date]]
                   _                 -> Right date
            compareDateFields :: T.Text -> R.RecordFieldGetter -> R.RecordFieldGetter -> R.EitherErrorsRecord
            compareDateFields message field1 field2 =
              case (parseDateDayFirst (field1 r), parseDateDayFirst (field2 r)) of
               (Right d1, Right d2) | d1 > d2 -> Left [T.concat [R.sampleId r, ": ", message, ": ", (field1 r), " vs. ", (field2 r)]]
               _                              -> Right r -- ignore date parsing errors, they were reported by validateField

    checkErrors checker records =
      let checked = Map.map checker records
          (map_errors, map_records) = Map.mapEither id checked
      in
       if Map.null map_errors
       then Right map_records
       else Left (concat $ Map.elems map_errors)
