sampleIdCeirs :: Record -> T.Text
sampleIdCeirs record =
  let raw = sampleId record
      prependCIP116 = T.take 4 raw == "217-"
  in if prependCIP116
     then T.concat ["CIP116", raw]
     else raw

----------------------------------------------------------------------

  initField {fColumn=17, fTitle="latitude", fRecord=setLatitude, fExport=latitude, fValidator=validatorFloat (-90.0) 90.0},
  initField {fColumn=18, fTitle="longitude", fRecord=setLongitude, fExport=longitude, fValidator=validatorFloat (-180.0) 180.0},
  initField {fColumn=19, fTitle="sample material", fRecord=setSampleMaterial, fExport=sampleMaterial, fValidator=validatorSampleMaterial},
  initField {fColumn=20, fTitle="test for influenza virus", fRecord=setTestforinfluenzaVirus, fExport=testForInfluenzaVirus}, -- fValidator=validatorTestFlu},
  initField {fColumn=21, fTitle="day of testing", fRecord=setDateOfTestingPart EDay, fExport=dateDay . dateOfTesting, fValidator=validatorDay},
  initField {fColumn=22, fTitle="month of testing", fRecord=setDateOfTestingPart EMonth, fExport=dateMonth . dateOfTesting, fValidator=validatorMonth},
  initField {fColumn=23, fTitle="year of testing", fRecord=setDateOfTestingPart EYear, fExport=dateYear . dateOfTesting, fValidator=validatorYear},
  initField {fColumn=24, fTitle="pool id", fRecord=setPoolId, fExport=poolId, fValidator=validatorNumber},
  initField {fColumn=25, fTitle="influenza test result", fRecord=setInfluenzatestResult, fExport=influenzaTestResult, fValidator=validatorRegexToUpper "^(P|N)$" "expected influenza test result: P, N"},
  initField {fColumn=26, fTitle="ma ct value", fRecord=setMactValue, fExport=maCtValue, fValidator=validatorCtValue},
  initField {fColumn=27, fTitle="h5 status", fRecord=setH5Status, fExport=h5Status, fValidator=validatorRegexToUpper "^(P|N)$" "expected H5 status: P, N"},
  initField {fColumn=28, fTitle="h5 ct value", fRecord=setH5ctValue, fExport=h5CtValue, fValidator=validatorCtValue},
  initField {fColumn=29, fTitle="h5 pathotype", fRecord=setH5Pathotype, fExport=h5Pathotype, fValidator=validatorRegexToUpper "^(LPAI|HPAI)$" "expected H5 pathotype: LPAI, HPAI"},
  initField {fColumn=30, fTitle="h7 status", fRecord=setH7Status, fExport=h7Status, fValidator=validatorRegexToUpper "^(P|N)$" "expected H7 status: P, N"},
  initField {fColumn=31, fTitle="h7 ct value", fRecord=setH7ctValue, fExport=h7CtValue, fValidator=validatorCtValue},
  initField {fColumn=32, fTitle="h7 pathotype", fRecord=setH7Pathotype, fExport=h7Pathotype, fValidator=validatorRegexToUpper "^(LPAI|HPAI)$" "expected H7 pathotype: LPAI, HPAI"},
  initField {fColumn=33, fTitle="h9 status", fRecord=setH9Status, fExport=h9Status, fValidator=validatorRegexToUpper "^(P|N)$" "expected H9 status: P, N"},
  initField {fColumn=34, fTitle="h9 ct value", fRecord=setH9ctValue, fExport=h9CtValue, fValidator=validatorCtValue},
  initField {fColumn=35, fTitle="emc id", fRecord=setEmcId, fExport=emcId},
  initField {fColumn=36, fTitle="ahvla id", fRecord=setAhvlaId, fExport=ahvlaId},
  initField {fColumn=37, fTitle="first egg passage", fRecord=setFirsteggPassage, fExport=firstEggPassage, fValidator=validatorRegexToUpper "^(0|1)$" "expected first egg passage: 0, 1"},
  initField {fColumn=38, fTitle="second egg passage", fRecord=setSecondeggPassage, fExport=secondEggPassage, fValidator=validatorRegexToUpper "^(0|1)$" "expected second egg passage: 0, 1"},
  initField {fColumn=39, fTitle="passage isolation", fRecord=setPassageIsolation, fExport=passageIsolation, fValidator=validatorRegexToUpper "^(E1|E2|NOT *PERFORMED|NEGATIVE)$" "expected passage isolation: E1, E2, not performed"},
  initField {fColumn=40, fTitle="virus pathotype", fRecord=setVirusPathotype, fExport=virusPathotype, fValidator=validatorRegexToUpper "^(LPAI|HPAI|NOT *IDENTIFIABLE)$" "expected virus pathotype: LPAI, HPAI, notidentifiable"},
  initField {fColumn=41, fTitle="haemagglutinin subtype", fRecord=setHaemagglutininSubtype, fExport=haemagglutininSubtype, fValidator=validatorRegexToUpper "^((H[1-9]|H1[0-6])(/(H[1-9]|H1[0-6]))*|MIXED|H +NOT +DETERMINED)$" "expected haemagglutinin subtype: H1-H16, mixed, H not determined"},
  initField {fColumn=42, fTitle="neuraminidase subtype", fRecord=setNeuraminidaseSubtype, fExport=neuraminidaseSubtype, fValidator=validatorRegexToUpper "^(N[1-9](/N[1-9])*|MIXED|N +NOT +DETERMINED)$" "expected neuraminidase subtype: N1-N9, mixed, N not determined"},
  initField {fColumn=43, fTitle="serology sample id", fRecord=setSerologySampleId, fExport=serologySampleId, fValidator=validatorSampleId},
  initField {fColumn=44, fTitle="serology testing day", fRecord=setSerologyTestingDatePart EDay, fExport=dateDay . serologyTestingDate, fValidator=validatorDay},
  initField {fColumn=45, fTitle="serology testing month", fRecord=setSerologyTestingDatePart EMonth, fExport=dateMonth . serologyTestingDate, fValidator=validatorMonth},
  initField {fColumn=46, fTitle="serology testing year", fRecord=setSerologyTestingDatePart EYear, fExport=dateYear . serologyTestingDate, fValidator=validatorYear},
  initField {fColumn=47, fTitle="serology status", fRecord=setSerologyStatus, fExport=serologyStatus, fValidator=validatorRegex "^(\\+|-|\\*)$" "expected serology status: +, -, *"},
  initField {fColumn=48, fTitle="*uuid*", fRecord=setUuid, fExport=uuid, fValidator=validatorUuid, fIgnoreInMerge=True}
  ]

----------------------------------------------------------------------

fieldErrorPrefixT :: Int -> Int -> T.Text -> T.Text
fieldErrorPrefixT rowNo colNo message = T.intercalate "" ["Error in cell ", ssheetRowColToText rowNo colNo, ": ", message]

fieldErrorPrefixTT :: Int -> Int -> [T.Text] -> T.Text
fieldErrorPrefixTT rowNo colNo messages = T.intercalate "" (["Error in cell ", ssheetRowColToText rowNo colNo, ": "] ++ messages)

fieldErrorPrefixS :: Int -> Int -> String -> T.Text
fieldErrorPrefixS rowNo colNo message = fieldErrorPrefixT rowNo colNo (T.pack message)

----------------------------------------------------------------------

normalizeFieldTitleText :: T.Text -> T.Text
normalizeFieldTitleText = T.replace "_" " " . T.toLower

validateFieldTitle :: [Cell] -> Field -> Maybe T.Text
validateFieldTitle cells field =
  let colNo = fColumn field
      expected = fTitle field
      cell = case drop colNo cells of
        [] -> CellEmpty
        cc -> head cc
  in
   case (expected, cell) of
    ("*uuid*", _) -> case validatorUuid Dirs.emptyDirectories cell of
                      Right _ -> Nothing
                      Left [t] -> Just $ fieldErrorPrefixS 1 colNo $ T.unpack t
                      _ -> Just $ fieldErrorPrefixS 1 colNo "original database id within DTRA system expected"
    (_, CellString text) | normalizeFieldTitleText text == expected -> Nothing
    _ -> Just $ fieldErrorPrefixS 1 colNo $ "invalid column label: \"" ++ cellAsString cell ++ "\" expected: \"" ++ T.unpack expected ++ "\""

----------------------------------------------------------------------

-- | Source file may contain columns in arbitrary order.
-- Figure out fColumn for each field by its title.
--
-- Returns either errors (e.g. fields not found) or list of Field with
-- fColumn set correctly. If field not found, fColumn is set to
-- -1. If field not found and fCanBeEmpty=False for it, error is
-- raised. Redundant fields found in [Cell] ignored.
findFields :: [Cell] -> [Field] -> Either [T.Text] [Field]
findFields cells {- sourceFields -} =
  foldr (sequenceField . findField) (Right []) {- sourceFields -}
  where
    findField field =
      case L.find (matchCell (fTitle field)) (zip [0..] normalizedCells) of
       Just (index, _)                      -> Right $ field { fColumn = index }
       Nothing | (fTitle field) == "*uuid*" -> Right $ field
       Nothing                              -> if fCanBeEmpty field
                                               then Right $ field { fColumn = -1 }
                                               else Left $ T.concat ["Mandatory column \"", fTitle field, "\" not found"]
    normalizedCells = map normalizeCell cells
    normalizeCell (CellString t) = normalizeFieldTitleText t
    normalizeCell _ = "*not string*"
    matchCell lookFor (_, t) = lookFor == t
    sequenceField (Right field) (Right accum) = Right (field : accum)
    sequenceField (Left err) (Right _) = Left [err]
    sequenceField (Right _) (Left accum) = Left accum
    sequenceField (Left err) (Left accum) = Left (err : accum)

----------------------------------------------------------------------

normalizeField :: Dirs.Directories -> Int -> [Cell] -> Field -> ValidatorResult
normalizeField directories rowNo cells field =
  let colNo = fColumn field
      validate = fValidator field directories
      cell = case drop colNo cells of -- Note empty cells at the tail of cells truncated
        [] -> CellEmpty
        cc -> head cc
  in
   -- trace ("normalizeField " ++ ssheetRowColToString rowNo colNo ++ " " ++ show cell) $
   if colNo >= 0 && cell /= CellEmpty -- negative colNo means field (column) is absent in the source file
   then
     -- trace ("normalizeField " ++ ssheetRowColToString rowNo colNo ++ " " ++ show cell) $
     case validate cell of
      Left [msg] -> Left [fieldErrorPrefixTT rowNo colNo ["\"", cellAsText cell, "\": ", msg]]
      result -> result
   else if fCanBeEmpty field
        then return ""
        else Left [fieldErrorPrefixT rowNo colNo "cannot be empty"]

----------------------------------------------------------------------
{- Field Validators -}
----------------------------------------------------------------------

validatorDefault :: Validator
validatorDefault _ cell = Right $ cellAsText cell
-- validatorDefault cell = Left [cellAsText cell]

validatorInvalid :: Validator
validatorInvalid _ cell = Left [cellAsText cell]

----------------------------------------------------------------------

validatorRegex :: T.Text -> T.Text -> Validator
validatorRegex regex_s err =
  let regex = Rex.makeRegexOpts (Rex.defaultCompOpt {Rex.caseSensitive=False}) (Rex.defaultExecOpt {Rex.captureGroups=False}) regex_s
      validator _ cell =
        let text = cellAsText cell
        in
         if Rex.match regex text
         then Right text
         else Left [err]
  in
   validator

----------------------------------------------------------------------

validatorRegexToUpper :: T.Text -> T.Text -> Validator
validatorRegexToUpper regex_s err =
  let regex = Rex.makeRegexOpts (Rex.defaultCompOpt {Rex.caseSensitive=True}) (Rex.defaultExecOpt {Rex.captureGroups=False}) regex_s
      validator _ cell =
        let textRaw = cellAsText cell
            text = T.toUpper textRaw
        in
         if Rex.match regex text
         then Right text
         else Left [err]
  in
   validator

----------------------------------------------------------------------

validatorDate :: Validator
validatorDate _ cell =
  case parseDateDayFirst $ cellAsText cell of
   Left err -> Left [err]
   Right day -> Right (showDay day)

validatorDay :: Validator
validatorDay _ cell =
  cellAsInt cell >>= validate
  where
    validate v = if v >= 1 && v <= 31 then Right (showInt2Digits v) else Left ["Invalid day"]

validatorMonth :: Validator
validatorMonth _ cell =
  cellAsInt cell >>= validate
  where
    validate v = if v >= 1 && v <= 12 then Right (showInt2Digits v) else Left ["Invalid month"]

validatorYear :: Validator
validatorYear _ cell =
  cellAsInt cell >>= validate
  where
    validate v = if v >= 2000 then Right (T.pack $ show v) else Left ["Invalid year"]

cellAsInt :: Cell -> Either [T.Text] Int
cellAsInt cell =
  case (readMaybe . cellAsString) cell of
      Just i -> Right i
      Nothing -> Left ["Unrecognized day"]

-- ----------------------------------------------------------------------

dateDay :: T.Text -> T.Text
dateDay = T.take 2

dateMonth :: T.Text -> T.Text
dateMonth = T.take 2 . T.drop 3

dateYear :: T.Text -> T.Text
dateYear = T.drop 6

-- ----------------------------------------------------------------------

showDay :: Day -> T.Text
showDay = T.pack . formatTime defaultTimeLocale "%d.%m.%Y"

showInt2Digits :: Int -> T.Text
showInt2Digits int = T.pack $ if int < 10 then "0" ++ show int else show int

-- showDayDay :: Day -> T.Text
-- showDayDay = T.pack . formatTime defaultTimeLocale "%d"

-- showDayMonth :: Day -> T.Text
-- showDayMonth = T.pack . formatTime defaultTimeLocale "%m"

-- showDayYear :: Day -> T.Text
-- showDayYear = T.pack . formatTime defaultTimeLocale "%Y"

----------------------------------------------------------------------

validatorFloat :: Float -> Float -> Validator
validatorFloat minValue maxValue =
  let validator :: Validator
      validator _ cell =
        let text = cellAsText cell
            -- isFloat :: Bool
            -- isFloat = text Rex.=~ ("^[-+]?[0-9]+(\\.[0-9]*)?$" :: T.Text)
            value :: Maybe Float
            value = readMaybe $ T.unpack text
        in
         case value of
          Just f | f >= minValue && f <= maxValue -> Right text
          _ -> Left [T.pack ("expected: float value in range " ++ show minValue ++ ".." ++ show maxValue)]
  in
   validator

----------------------------------------------------------------------

-- TS = Tracheal swab
-- OP = Oral-pharyngeal
-- C = Cloacal
-- F = Feces
-- COP = Cloacal and oral-pharyngeal samples, when combined into one sample
-- B= Blood
-- SR = Serum
-- TT = Tissue from trachea
-- CF = Cloacal and fecal samples, when combined into one sample
-- TB = Tissue from brain
-- TO = Other tissue
-- L = Lungs
-- S = Soil
-- W = Water
-- O = Other; plus free typed out text (e.g. O - feather)
-- U = Unknown

validatorSampleMaterial :: Validator
validatorSampleMaterial = validatorRegexToUpper "^(TS|OP|C|F|COP|B|SR|TT|CF|TB|TO|L|S|W|O[- ].+|X.*)$" "expected: TS, OP, C, F, COP, B, SR, TT, CF, TB, TO, L, S, W, O -<text>, X-<text>"

----------------------------------------------------------------------

validatorTestFlu :: Validator
-- validatorTestFlu = validatorRegexToUpper "^RRT-PCR +(MA|H5|H7)$" "expected: RRT-PCR MA, RRT-PCR H5, RRT-PCR H7"
validatorTestFlu = validatorRegexToUpper "^RRT-PCR +MA( *,? *RRT-PCR +H5( *,? *RRT-PCR +H7)?)?$" "expected: RRT-PCR MA, RRT-PCR H5, RRT-PCR H7"

----------------------------------------------------------------------

validatorNumber :: Validator
validatorNumber = validatorRegex "^[0-9\\.]+$" "expected: numeric value"

----------------------------------------------------------------------

validatorCtValue :: Validator
validatorCtValue = validatorRegex "^[<>]?[0-9]+(\\.[0-9][0-9]?)?$" "expected: valid CT Value"

----------------------------------------------------------------------

validatorUuid :: Validator
-- validatorUuid = validatorRegex "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$" "expected: orinating database id within DTRA system"
validatorUuid = validatorRegex "^.+$" "expected: orinating database id within DTRA system"

----------------------------------------------------------------------

validatorDirectories :: T.Text -> (Dirs.Directories -> T.Text -> Maybe a) -> Validator
validatorDirectories err find directories cell =
  let text = cellAsText cell
  in
   maybe (Left [err]) (\_ -> Right text) (find directories text)

----------------------------------------------------------------------

fieldByColumnNo :: T.Text -> Int -> Field
fieldByColumnNo version columnNo =
  fromMaybe (error ("No field for column " ++ show columnNo)) (L.find fNo (fields version))
  where
    fNo field = fColumn field == columnNo

----------------------------------------------------------------------

fRecordByColumnNo :: T.Text -> Int -> RecordFieldSetter
fRecordByColumnNo version = fRecord . fieldByColumnNo version

----------------------------------------------------------------------

makeRecord :: T.Text -> [T.Text] -> Record
-- makeRecord fieldList | trace ("makeRecord: " ++ show (head fieldList)) False = undefined
makeRecord version fieldList =
  foldl updateRecord emptyRecord (zip fieldList [0..])
  where
    updateRecord record (value, columnNo) = fRecordByColumnNo version columnNo record value

----------------------------------------------------------------------

recordToList :: T.Text -> Record -> [T.Text]
-- recordToList version record | trace ("recordToList " ++ show record) False = undefined
recordToList version record =
  let columnExport = map (\f -> (fColumn f, fExport f)) (fieldsToExportDTRA version)
      numColumns = fst (L.maximumBy (L.comparing fst) columnExport) + 1
      initResult = Seq.replicate numColumns ("" :: T.Text)
      updateResult result (colNo, export) = Seq.update colNo (export record) result
  in
   Seq.toList $ foldl updateResult initResult columnExport

----------------------------------------------------------------------

-- recordToListCeirs :: Record -> [T.Text]
-- recordToListCeirs record =
--   let columnExport =
--         map columnExporter fieldsToExportCeirs
--         where
--           columnExporter f =
--             case fExportCeirs f of
--              Just export -> (fColumn f, export)
--              Nothing -> (fColumn f, fExport f)
--       numColumns = fst (L.maximumBy (L.comparing fst) columnExport) + 1
--       initResult = Seq.replicate numColumns ("" :: T.Text)
--       updateResult result (colNo, export) = Seq.update colNo (export record) result
--   in
--    Seq.toList $ foldl updateResult initResult columnExport

----------------------------------------------------------------------

titlesToList :: T.Text -> T.Text -> [T.Text]
titlesToList version uuidOfSheet =
  let columnTitle = map (\f -> (fColumn f, fTitle f)) (fieldsToExportDTRA version)
      numColumns = fst (L.maximumBy (L.comparing fst) columnTitle) + 1
      initResult = Seq.replicate numColumns ("" :: T.Text)
      updateResult result (colNo, title) = Seq.update colNo (if title == "*uuid*" then uuidOfSheet else title) result
  in
   Seq.toList $ foldl updateResult initResult columnTitle

----------------------------------------------------------------------

-- titlesToListCeirs :: [T.Text]
-- titlesToListCeirs =
--   let columnTitle = map (\f -> (fColumn f, fTitle f)) fieldsToExportCeirs
--       numColumns = fst (L.maximumBy (L.comparing fst) columnTitle) + 1
--       initResult = Seq.replicate numColumns ("" :: T.Text)
--       updateResult result (colNo, title) = Seq.update colNo title result
--   in
--    Seq.toList $ foldl updateResult initResult columnTitle

----------------------------------------------------------------------

fieldsToExport :: T.Text -> (Field -> Bool) -> [Field]
fieldsToExport version filterBy = filter filterBy (fields version)

fieldsToExportDTRA :: T.Text -> [Field]
-- fieldsToExportDTRA version | trace ("fieldsToExportDTRA: " ++ show (fieldsToExport version (const True))) False = undefined
fieldsToExportDTRA version = fieldsToExport version (const True)

fieldsToExportCeirs :: [Field]
fieldsToExportCeirs = fieldsToExport "1" (\f -> fTitle f /= "*uuid*")

----------------------------------------------------------------------

    ----------------------------------------------------------------------
    {-| Checks Host species and Host common name correspondence, in case one of them is not filled, fill it (via Directories).
        Returns either list of errors or corrected map of records.
     -}
    updateHostSpeciesCommonName :: R.MapRecords -> R.EitherErrorsRecords
    updateHostSpeciesCommonName {- records -} =
      checkErrors checkRecord {- records -}
      where
        checkRecord record =
          let notFound = "*not found*"
              species = R.hostSpecies record
              species' = U.normalizeText species
              commonName = R.hostCommonName record
              commonName' = U.normalizeText commonName
              newSpecies = fromMaybe notFound (Dirs.birdListFindEnglish directories commonName')
              newCommonName = fromMaybe notFound (Dirs.birdListFindScientific directories species')
              err = Left [T.toStrict $ F.format (F.text % ": $$$ host species (" % F.text % ") and host common name (" % F.text % ") do not correspond to each other (you may fill one of those fields and let the system to fill the other)")
                          (R.sampleId record) species commonName]
              errNull = Left [T.toStrict $ F.format (F.text % ": Neither host species nor host common name provided, please put one of them, the system will fill the other")
                              (R.sampleId record)]
              update cn sp
                --- | trace ("updateHostSpeciesCommonName: " ++ T.unpack (F.format (F.text % ": host species: \"" % F.text % "\"  commnon name: \"" % F.text % "\"") (R.sampleId record) species commonName)) False = undefined
                | T.null cn && newCommonName /= notFound = -- correct species, empty common name
                    Right $ record { R.hostCommonName = newCommonName }
                | T.null sp && newSpecies /= notFound = -- correct common name, empty species
                    Right $ record { R.hostSpecies = newSpecies }
                | not (T.null sp) && cn == U.normalizeText newCommonName = -- both fields non-empty, correct, correspond to each other
                    Right record
                -- errors
                | T.null cn && T.null sp = -- both fields empty
                    errNull
                | T.null cn && newCommonName == notFound = -- empty common name, species not found
                    Left [T.toStrict $ F.format (F.text % ": host species \"" % F.text % "\" not found in the database, common name is empty") (R.sampleId record) species]
                | T.null sp && newSpecies == notFound = -- empty species, common name not found
                    Left [T.toStrict $ F.format (F.text % ": common name \"" % F.text % "\" not found in the database, species is empty") (R.sampleId record) commonName]
                | not (T.null cn) && not (T.null sp) && newSpecies == notFound && newCommonName /= notFound = -- common name not found, species found
                    Left [T.toStrict $ F.format (F.text % ": common name \"" % F.text % "\" not found in the database, species \"" % F.text % "\" found and gives common name \"" % F.text % "\"") (R.sampleId record) commonName species newCommonName]
                | not (T.null cn) && not (T.null sp) && newSpecies /= notFound && newCommonName == notFound = -- common name found, species not found
                    Left [T.toStrict $ F.format (F.text % ": species \"" % F.text % "\" not found in the database, common name \"" % F.text % "\" found and gives species \"" % F.text % "\"") (R.sampleId record) species commonName newSpecies]
                | not (T.null cn) && not (T.null sp) && newSpecies /= notFound && newCommonName /= notFound = -- both found, but do not correspond
                    Left [T.toStrict $ F.format (F.text % ": common name \"" % F.text % "\" (--> " % F.text % ") and species \"" % F.text % "\" (--> " % F.text % ") found in the database but do not correspond to each other") (R.sampleId record) commonName newSpecies species newCommonName]
                | not (T.null cn) && not (T.null sp) && newSpecies == notFound && newCommonName == notFound = -- both not found
                    Left [T.toStrict $ F.format (F.text % ": neither common name \"" % F.text % "\" nor species \"" % F.text % "\" found in the database") (R.sampleId record) commonName species]
                | otherwise = err -- trace ("sp:" ++ show cn ++ "->" ++ show newSpecies ++ " cn:" ++ show sp ++ "->" ++ show newCommonName) err
          in
           update commonName' species'

    updateLocations :: R.MapRecords -> R.EitherErrorsRecords
    updateLocations =
      checkErrors checkRecord
      where
        checkRecord record =
          let sampleId = R.sampleId record
              location = R.location record
              locationRecMaybe = Dirs.locationFind' directories location
              locationRec = fromJust locationRecMaybe
              err fieldName got expected = Left [T.concat [sampleId, ": invalid ", fieldName, " for ", location, ": ", got, " (expected: ", expected, ")",
                                                           ", please leave Province, Country, Latitude, Longitude fields empty to allow system to fill them with the correct content"]]
              checkField fieldName gotF expectedF = unless
                                                    (T.null (gotF record) || U.normalizeText (expectedF locationRec) == U.normalizeText (gotF record))
                                                    (err fieldName (gotF record) (expectedF locationRec))
              checkFieldFloat fieldName gotF expectedF = unless
                                                    (T.null (gotF record) || readFloat (expectedF locationRec) == readFloat (gotF record))
                                                    (err fieldName (gotF record) (expectedF locationRec))
              readFloat :: T.Text -> Float
              readFloat source =
                case (readMaybe . T.unpack . U.normalizeText) source of
                 Just f -> f
                 Nothing -> trace ("updateLocations: No float in " ++ T.unpack source) (-1.0)
          in do
            when (isNothing locationRecMaybe) (Left [T.concat [sampleId, ": location not found: ", location]])
            checkField "province" R.province Dirs.province
            checkField "country" R.country Dirs.country
            checkFieldFloat "latitude" R.latitude Dirs.latitude
            checkFieldFloat "longitude" R.longitude Dirs.longitude
            Right record { R.province=Dirs.province locationRec, R.country=Dirs.country locationRec, R.latitude=Dirs.latitude locationRec, R.longitude=Dirs.longitude locationRec }

    -- Nic 2015-02-10: If 'domesticus' in the species field please autofill behavior as D, All other species entries please autofill behavior as W
    updateBehavior :: R.MapRecords -> R.EitherErrorsRecords
    updateBehavior =
      checkErrors checkRecord
      where
        checkRecord :: R.Record -> R.EitherErrorsRecord
        checkRecord record =
          let species = U.normalizeText $ R.hostSpecies record
              domesticus = "domesticus" `T.isInfixOf` species
              behavior_orig = R.behavior record
              behavior = if not (T.null behavior_orig) then behavior_orig else if domesticus then "D" else "W"
          in
           Right record { R.behavior = behavior }

    -- In version 2 format date fields are constructed from parts (day, month, year) without checking
    checkDates :: R.MapRecords -> R.EitherErrorsRecords
    checkDates =
      checkErrors checkRecord
      where
        checkRecord :: R.Record -> R.EitherErrorsRecord
        checkRecord r =
          case errors of
           [] -> Right r
           _  -> Left errors
          where
            errors =
              concat $ lefts [ validateField "collection date" R.collectionDate
                             , validateField "date of testing" R.dateOfTesting
                             , validateField "serology testing date" R.serologyTestingDate
                             , compareDateFields "collection date > date of testing" R.collectionDate R.dateOfTesting
                             , compareDateFields "collection date > serology testing date" R.collectionDate R.serologyTestingDate
                             ]
            validateField name field =
              case validateDate (field r) of
               Left err -> Left err
               Right _ -> Right r
              where
                validateDate date =
                  case (T.null date, parseDateDayFirst date) of
                   (False, Left err) -> Left [T.concat [R.sampleId r, ": ", name, ": ", err, ": ", date]]
                   _                 -> Right date
            compareDateFields :: T.Text -> R.RecordFieldGetter -> R.RecordFieldGetter -> R.EitherErrorsRecord
            compareDateFields message field1 field2 =
              case (parseDateDayFirst (field1 r), parseDateDayFirst (field2 r)) of
               (Right d1, Right d2) | d1 > d2 -> Left [T.concat [R.sampleId r, ": ", message, ": ", (field1 r), " vs. ", (field2 r)]]
               _                              -> Right r -- ignore date parsing errors, they were reported by validateField

    checkErrors checker records =
      let checked = Map.map checker records
          (map_errors, map_records) = Map.mapEither id checked
      in
       if Map.null map_errors
       then Right map_records
       else Left (concat $ Map.elems map_errors)
