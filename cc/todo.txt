sampleIdCeirs :: Record -> T.Text
sampleIdCeirs record =
  let raw = sampleId record
      prependCIP116 = T.take 4 raw == "217-"
  in if prependCIP116
     then T.concat ["CIP116", raw]
     else raw

----------------------------------------------------------------------

  initField {fColumn=48, fTitle="*uuid*", fRecord=setUuid, fExport=uuid, fValidator=validatorUuid, fIgnoreInMerge=True}
  ]

----------------------------------------------------------------------

normalizeFieldTitleText :: T.Text -> T.Text
normalizeFieldTitleText = T.replace "_" " " . T.toLower

validateFieldTitle :: [Cell] -> Field -> Maybe T.Text
validateFieldTitle cells field =
  let colNo = fColumn field
      expected = fTitle field
      cell = case drop colNo cells of
        [] -> CellEmpty
        cc -> head cc
  in
   case (expected, cell) of
    ("*uuid*", _) -> case validatorUuid Dirs.emptyDirectories cell of
                      Right _ -> Nothing
                      Left [t] -> Just $ fieldErrorPrefixS 1 colNo $ T.unpack t
                      _ -> Just $ fieldErrorPrefixS 1 colNo "original database id within DTRA system expected"
    (_, CellString text) | normalizeFieldTitleText text == expected -> Nothing
    _ -> Just $ fieldErrorPrefixS 1 colNo $ "invalid column label: \"" ++ cellAsString cell ++ "\" expected: \"" ++ T.unpack expected ++ "\""

----------------------------------------------------------------------
merge
----------------------------------------------------------------------

mergeRecords :: T.Text -> T.Text -> T.Text -> R.Record -> R.Record -> Bool -> Either [T.Text] R.Record
mergeRecords version uuid key master mergeIn resolveNew =
  -- foldlM processField' R.emptyRecord F.fields >>= Right . addUuid uuid
  foldl updateRecord (Right R.emptyRecord) processFields >>= Right . addUuid uuid
  where
    updateRecord errorOrRecord errorOrValue =
      case (errorOrRecord, errorOrValue) of
       (Right record, Right (value, setter)) -> Right (setter record value)
       (Left e, Right _) -> Left e
       (Right _, Left e) -> Left e
       (Left previous_errors, Left new_errors) -> Left (previous_errors ++ new_errors)
    processFields :: [Either [T.Text] (T.Text, R.Record -> T.Text -> R.Record)]
    processFields =
      map processField (F.fields version)
    processField :: F.Field -> Either [T.Text] (T.Text, R.Record -> T.Text -> R.Record)
    processField field =
      let getter = F.fExport field
          setter = F.fRecord field
          title = F.fTitle field
          ignore = F.fIgnoreInMerge field
      in
       case (getter master, getter mergeIn) of
        (ma, me) | T.null me || T.toLower ma == T.toLower me || ignore -> Right (ma, setter)
        (ma, me) | T.null ma && not (T.null me) -> Right (me, setter)
        (ma, me) ->
          case resolveConflictForField field master ma me resolveNew of
           Nothing -> Left [T.concat ["Conflict for \"", key, "\" field \"", title, "\": master:'", ma, "' vs. new:'", me, "'"]]
           Just valueToUse -> Right (valueToUse, setter)

resolveConflictForField :: F.Field -> R.Record -> T.Text -> T.Text -> Bool -> Maybe T.Text
-- If "capture method/capture status" is not K, then "health" is not U (situation with K is fixed by R.fixRecord)
resolveConflictForField field master masterValue newValue resolveNew
  | F.fTitle field == "health" && R.captureMethodStatus master /= "K" =
      case (masterValue, newValue) of
       ("H", "U") -> Just "H"
       ("U", "H") -> Just "H"
       _ -> Nothing

  -- prefer K over A for "capture method/capture status"
  | F.fTitle field == "capture method/capture status" =
      case (masterValue, newValue) of
       ("K", "A") -> Just "K"
       ("A", "K") -> Just "K"
       _ -> Nothing

  -- prefer A over U for "age"
  | F.fTitle field == "age" =
      case (masterValue, newValue) of
       ("U", "A") -> Just "A"
       ("A", "U") -> Just "A"
       _ -> if resolveNew then Just newValue else Nothing

  -- prefer most recent collection date
  | F.fTitle field == "collection date" =
      Just $ mostRecentDateDayFirst masterValue newValue

  {- already fixed by fixRecord (see description there)
   -- prefer TS over OP for "sample material"
  | F.fTitle field == "sample material" =
      case (masterValue, newValue) of
       ("TS", "OP") -> Just "TS"
       ("OP", "TS") -> Just "TS"
       _ -> Nothing
  -}

  | otherwise = if resolveNew then Just newValue else Nothing
